task_id,task_name,status,agent_owner,priority,dependencies,notes,created_date,updated_date,estimated_effort,actual_effort
TASK-001,Project initialization and architecture documentation review,Completed,Scrum Master,High,,Reviewed update_notes.json to understand current state: dual Raspberry Pi Pico 2W Master-Slave architecture already implemented. Master handles keyboard capture (GP2/GP3 I2C1 for TCA8418). Slave handles display refresh (GP10/GP11 SPI1 for Waveshare 4.2 inch). UART communication at 115200 baud on GP8/GP9. Migration from ESP32-S3 completed in Update 2. Current focus: optimize dual-core usage within each Pico and implement async to prevent blocking.,2025-10-15,2025-10-15,Small,30min
TASK-002,Analyze existing codebase structure and identify blocking operations,Completed,Code Architect,High,TASK-001,"Analyzed main.py variants: (1) main.py - standard blocking version, (2) main_improved.py - duplicate of main.py, (3) main_optimized.py - uses _thread for display worker thread with queue-based updates. Master (rpi1/main.py) runs keyboard scanning in tight loop with UART commands sent to slave. Slave (rpi2/main.py) receives UART commands and renders display. Blocking operations identified: (a) Display refresh in slave main loop, (b) File I/O operations in master, (c) WiFi uploads in master, (d) Keyboard scanning tight loop in master. Opportunity: leverage second core in each Pico for parallel processing.",2025-10-15,2025-10-15,Medium,1hr
TASK-003,Review Raspberry Pi Pico 2W (RP2350) hardware specifications and dual-core capabilities,Completed,Hardware Specialist,High,TASK-001,"RP2350 processor features: Dual Cortex-M33 cores at 150MHz, 520KB SRAM, hardware floating point, PIO state machines, DMA controllers. MicroPython on RP2 supports _thread module for multicore programming. Core 0 runs main script by default. Core 1 can be started with _thread.start_new_thread(). Shared memory between cores with lock primitives available. Best practices: use core affinity, minimize lock contention, use message passing for inter-core communication. Async with uasyncio also available but threading preferred for I/O-bound tasks on RP2350.",2025-10-15,2025-10-15,Medium,45min
TASK-004,Document current pin assignments and hardware connections,Completed,Hardware Specialist,Medium,TASK-003,"Master Pico (rpi1): TCA8418 keyboard on I2C1 (GP2 SDA / GP3 SCL / GP20 INT / GP21 RST), UART to Slave on GP8 TX / GP9 RX. Slave Pico (rpi2): Waveshare 4.2 inch e-ink on SPI1 (GP10 SCK / GP11 MOSI / GP13 CS / GP14 DC / GP15 RST / GP16 BUSY), UART from Master on GP9 TX / GP8 RX. Power management: Master controls lightsleep after 2min screensaver and 5min auto-off. Both Picos share ground. Reference document: ESP32_to_Pico2W_Pinout_Conversion.md contains complete migration mapping.",2025-10-15,2025-10-15,Small,30min
TASK-005,Design dual-core architecture strategy for Master Pico,In Progress,System Architect,Critical,TASK-002,"DESIGN: Core 0 (Master) - Keyboard scanning loop with TCA8418, processes keypresses, maintains text buffer, manages file operations. Core 1 (Master) - Background file I/O (auto-save every 2s), WiFi operations (Todoist upload, file transfer), garbage collection. Communication via thread-safe queue for file save requests and upload commands. Benefits: keyboard scanning never blocked by slow file writes or network operations. Locks needed for: text_buffer access, file_dirty flag, ACTIVE_FILE path. Lock-free design for keyboard input to Core 0 queue ensures zero latency.",2025-10-15,2025-10-15,Large,
TASK-006,Design dual-core architecture strategy for Slave Pico,Pending,System Architect,Critical,TASK-002,"DESIGN: Core 0 (Slave) - UART command receiver, command parser, manages display state, handles power management. Core 1 (Slave) - Display rendering worker, processes render queue with throttling, executes actual e-ink refresh operations, manages display busy states. Communication via thread-safe queue for render commands. Benefits: UART processing never blocked by 1.5s display refresh cycles. Slave can queue multiple updates and deduplicate/throttle intelligently. Locks needed for: display buffer access, command acknowledgment. Priority system: POWER_OFF/WAKE_UP highest, RENDER_TEXT with cursor medium, SCREENSAVER low.",2025-10-15,2025-10-15,Large,
TASK-007,Design async operation patterns using uasyncio,Pending,System Architect,High,TASK-005,"DESIGN: Evaluate uasyncio for high-level coordination in Master. Async tasks: (1) keyboard_scan_task() - reads TCA8418 events without blocking, (2) text_processing_task() - handles character insertion/deletion, (3) display_command_task() - sends UART commands to Slave, (4) file_save_task() - periodic auto-save, (5) power_management_task() - tracks idle time and triggers screensaver/sleep. Event-driven design with asyncio queues instead of thread locks where possible. Hybrid approach: threading for Core 1 background work, asyncio for Core 0 event coordination. Simpler than pure threading and more pythonic for I/O coordination.",2025-10-15,2025-10-15,Large,
TASK-008,Create detailed implementation plan with task breakdown,Completed,Scrum Master,High,TASK-005,"Implementation phases: PHASE 1 - Core infrastructure (queue system, lock primitives, thread lifecycle management). PHASE 2 - Master Pico dual-core implementation (Core 0: keyboard+text, Core 1: file I/O). PHASE 3 - Slave Pico dual-core implementation (Core 0: UART receiver, Core 1: display rendering). PHASE 4 - Async refactoring for Master using uasyncio. PHASE 5 - Integration testing and performance validation. PHASE 6 - Optimization and polish. Each phase has specific tasks with dependencies tracked in this CSV. Total estimated timeline: 2-3 weeks for full implementation and testing.",2025-10-15,2025-10-15,Medium,1hr
TASK-009,Implement thread-safe queue system for Master Pico inter-core communication,Pending,Core Developer,High,TASK-005,"Implement FileOperationQueue class with methods: enqueue_save(filename, content), enqueue_upload(filename, service), dequeue_with_timeout(). Use _thread.allocate_lock() for queue access protection. Implement SaveOperation and UploadOperation data classes to encapsulate operation details. Add priority levels: CRITICAL (user-initiated save), HIGH (auto-save), LOW (background upload). Queue max size: 10 operations with overflow handling. Location: create new file master_queue.py in rpi1/ directory. Include unit tests for concurrent access patterns.",2025-10-15,2025-10-15,Medium,
TASK-010,Implement thread-safe queue system for Slave Pico inter-core communication,Pending,Core Developer,High,TASK-006,"Implement DisplayCommandQueue class with methods: enqueue_render(text, cursor_pos, priority), enqueue_power(state), dequeue_with_timeout(). Use _thread.allocate_lock() for queue access protection. Implement DisplayCommand data class with command type, payload, priority, timestamp. Add intelligent deduplication: collapse multiple RENDER_TEXT commands if newer one supersedes. Queue max size: 5 commands (display is slow, deep queue not helpful). Location: create new file slave_queue.py in rpi2/ directory. Include command aging and priority boost for old commands.",2025-10-15,2025-10-15,Medium,
TASK-011,Refactor Master Pico main.py to initialize dual-core with Core 1 worker thread,Pending,Core Developer,Critical,"TASK-009,TASK-005","Update rpi1/main.py: (1) Import _thread and master_queue modules, (2) Create global locks for text_buffer and shared state, (3) Implement file_io_worker_thread() function for Core 1 startup, (4) Start Core 1 thread before entering main event loop with _thread.start_new_thread(file_io_worker_thread, ()), (5) Modify save_current_page() to enqueue save operation instead of blocking write, (6) Add thread monitoring and restart logic if Core 1 crashes. Keep keyboard scanning on Core 0 unchanged to maintain zero-latency input. Test with print statements to verify both cores running.",2025-10-15,2025-10-15,Large,
TASK-012,Implement file I/O worker on Master Pico Core 1,Pending,Core Developer,High,TASK-011,"Implement file_io_worker_thread() in rpi1/main.py: Infinite loop that dequeues file operations from FileOperationQueue. For save operations: acquire text_buffer lock, read buffer copy, release lock, perform file write, update file_dirty flag. For upload operations: read file content, call wifi_transfer or todoist_upload functions, handle errors with retry logic (max 3 attempts). Add watchdog timer to detect hung operations (timeout 30s for network, 5s for file I/O). Log all operations to operations.log with timestamps. Implement graceful shutdown on STOP command from Core 0.",2025-10-15,2025-10-15,Large,
TASK-013,Add lock protection for shared state in Master Pico,Pending,Core Developer,High,TASK-011,"Add lock protection in rpi1/main.py for shared data structures: (1) text_buffer_lock - protects text_buffer list during concurrent read/write, (2) file_state_lock - protects file_dirty, ACTIVE_FILE, current_page_index, (3) ui_state_lock - protects in_menu, in_paged_view flags. Update all functions that access these structures: insert_char(), delete_char(), save_current_page(), load_pages(), refresh_display(), file_menu(). Pattern: acquire lock, perform minimal critical section work, release lock. Avoid holding locks during I/O operations. Validate no deadlocks with lock ordering discipline: always acquire in order (text > file > ui) if multiple needed.",2025-10-15,2025-10-15,Medium,
TASK-014,Refactor Slave Pico main.py to initialize dual-core with Core 1 display worker,Pending,Core Developer,Critical,"TASK-010,TASK-006","Update rpi2/main.py: (1) Import _thread and slave_queue modules, (2) Create global locks for display buffer and epd driver access, (3) Implement display_worker_thread() function for Core 1 startup, (4) Start Core 1 thread before entering UART receiver loop with _thread.start_new_thread(display_worker_thread, ()), (5) Modify UART command handlers to enqueue display operations instead of direct rendering, (6) Send acknowledgment after enqueue not after render completion for faster response. Keep UART receiver on Core 0 to maintain command responsiveness. Add health check ping/pong between cores every 10s.",2025-10-15,2025-10-15,Large,
TASK-015,Implement display rendering worker on Slave Pico Core 1,Pending,Core Developer,High,TASK-014,"Implement display_worker_thread() in rpi2/main.py: Infinite loop that dequeues display commands from DisplayCommandQueue. For RENDER_TEXT: calculate layout with TextLayout, update frame buffer, call epd.EPD_4IN2_V2_PartialDisplay() with 1.5s refresh. For SCREENSAVER: render 'Linson' centered, full refresh. For POWER_OFF: call epd.Sleep() and enter low-power wait state. For CLEAR: full white screen refresh. Implement smart throttling: if multiple renders queued, skip intermediate and render only latest. Add display busy detection: if epd busy, wait with timeout 3s before forcing reset. Measure and log refresh timing for performance analysis.",2025-10-15,2025-10-15,Large,
TASK-016,Add lock protection for display resources in Slave Pico,Pending,Core Developer,High,TASK-014,"Add lock protection in rpi2/main.py for display resources: (1) display_lock - protects epd driver instance during SPI operations, (2) framebuffer_lock - protects frame buffer during text rendering calculations. Update display_worker_thread() to acquire display_lock before any epd calls. Update UART command handlers (STATUS, immediate power operations) that might need display access. Ensure display_lock released if exception occurs during refresh. Add lock timeout (5s) to detect deadlock scenarios. Consider lock-free design for frame buffer if possible using double-buffering technique.",2025-10-15,2025-10-15,Medium,
TASK-017,Implement async main loop for Master Pico using uasyncio,Pending,Core Developer,High,"TASK-013,TASK-007","Refactor rpi1/main.py main() function to async def main_async(): Create async tasks using asyncio.create_task(): (1) keyboard_scanner() - polls TCA8418, yields between checks, (2) text_processor() - processes key events from async queue, (3) uart_commander() - sends display update commands, (4) idle_monitor() - tracks activity for power management, (5) heartbeat() - monitors Core 1 health. Replace blocking time.sleep() calls with await asyncio.sleep(). Replace while True with async event loop. Keep Core 1 file_io_worker as thread not async task. Entry point: asyncio.run(main_async()). Benefits: simpler coordination than pure threading, natural I/O multiplexing, cleaner error handling.",2025-10-15,2025-10-15,XLarge,
TASK-018,Create async keyboard scanner task for Master Pico,Pending,Core Developer,Medium,TASK-017,"Implement async def keyboard_scanner() in rpi1/main.py: Async infinite loop that calls keyboard.scan_keys() and keyboard.read_key_event(), publishes events to asyncio.Queue (key_event_queue), yields control with await asyncio.sleep_ms(10) between scans for responsiveness. Non-blocking interrupt detection with keyboard.has_interrupt() check. Handle special keys: Fn combinations, Ctrl sequences, Shift state. Maintain minimal state: shift_pressed, ctrl_pressed, fn_pressed booleans. Error handling: if TCA8418 I2C fails, log error and retry after 100ms. Performance target: sub-50ms event publication latency from physical keypress to queue.",2025-10-15,2025-10-15,Medium,
TASK-019,Create async text processor task for Master Pico,Pending,Core Developer,Medium,TASK-017,"Implement async def text_processor() in rpi1/main.py: Async infinite loop that awaits key_event_queue.get(), processes character insertion/deletion with lock-protected text_buffer access, updates cursor_index and marks display_dirty flag, triggers display refresh via UART command. Handles special commands: backspace (with smart cross-page), enter (newline insertion), page break (--- insertion). Batching optimization: accumulate rapid keypresses (typing burst detection) and send single UART command for multiple chars to reduce display command overhead. Await asyncio.sleep(0) after processing to yield control. Target: process 100 chars/sec typing speed without lag.",2025-10-15,2025-10-15,Medium,
TASK-020,Create async UART commander task for Master Pico,Pending,Core Developer,Medium,TASK-017,"Implement async def uart_commander() in rpi1/main.py: Async infinite loop that monitors display_dirty flag, constructs JSON UART commands for Slave, sends via UART with proper framing (newline-delimited JSON), awaits acknowledgment with timeout. Command types: RENDER_TEXT (sends full visible text + cursor), SHOW_SCREENSAVER (on 2min idle), POWER_OFF (on 5min idle), WAKE_UP (on key activity). Smart command generation: only send RENDER if buffer changed, include sequence number for Slave to detect missing commands. Handle UART errors: retry up to 3 times, log failures. Non-blocking UART writes: use StreamWriter if available in micropython UART implementation.",2025-10-15,2025-10-15,Medium,
TASK-021,Create async idle monitor and power management task for Master Pico,Pending,Core Developer,Medium,TASK-017,"Implement async def idle_monitor() in rpi1/main.py: Track last_activity_ms timestamp updated by keyboard_scanner. Check elapsed time every 10s with await asyncio.sleep(10). At 2min (120s): trigger screensaver by setting screensaver_active flag and sending SHOW_SCREENSAVER command to Slave. At 5min (300s): trigger auto-off by sending POWER_OFF to Slave and entering machine.lightsleep() on Master until interrupt. Wake logic: TCA8418 INT pin (GP20) configured as wake source, on wake send WAKE_UP command to Slave and resume normal operation. Reset last_activity_ms on any key event. Add manual power-off: Fn+Q held for 2s (FN_HOLD_MS) triggers immediate shutdown sequence.",2025-10-15,2025-10-15,Medium,
TASK-022,Implement Core 1 health monitoring and restart mechanism,Pending,Core Developer,Medium,"TASK-012,TASK-017","Add thread monitoring to rpi1/main.py: Core 1 file_io_worker sets heartbeat_timestamp global variable every 5s. Core 0 async heartbeat() task checks timestamp every 10s with await asyncio.sleep(10). If timestamp stale (>15s), assume Core 1 hung or crashed. Recovery: attempt graceful stop by setting worker_stop_flag, wait 2s, if still hung force restart with _thread.start_new_thread(file_io_worker_thread, ()). Log all restart events to error.log with timestamp and suspected cause. Track restart count: if >3 restarts in 1 minute, disable Core 1 worker and fall back to single-core blocking mode with user warning on display.",2025-10-15,2025-10-15,Medium,
TASK-023,Optimize display command protocol for reduced UART overhead,Pending,Protocol Engineer,Medium,TASK-020,"Analyze current JSON UART protocol for efficiency. Optimizations: (1) Use compact JSON (no whitespace), (2) Implement abbreviated field names (cmd instead of command, txt instead of text), (3) Add differential updates for RENDER_TEXT - send only changed text region not full screen, (4) Implement command compression for repeated characters (e.g. 20 spaces as {char:' ',count:20}), (5) Add binary protocol mode for high-frequency commands with struct packing. Maintain backward compatibility: version field in handshake. Measure UART bandwidth: target <1KB per RENDER command. Update both rpi1/main.py and rpi2/main.py protocol handlers. Document protocol v2 spec in UART_Protocol.md.",2025-10-15,2025-10-15,Large,
TASK-024,Implement display command deduplication and throttling in Slave Pico,Pending,Core Developer,Medium,TASK-015,"Add intelligent queue management to slave_queue.py: (1) Deduplication - if RENDER_TEXT command arrives while previous RENDER still in queue, replace old with new (user only sees latest), (2) Throttling - enforce minimum 200ms between RENDER operations to prevent display thrashing, (3) Priority boost - if command waits >5s, boost priority to prevent starvation, (4) Adaptive refresh - during typing bursts (3+ RENDER in 1s) switch to slower refresh rate to reduce wear. Maintain FIFO order for power commands (WAKE/SLEEP/OFF). Add queue statistics: track queue depth, average wait time, dropped commands. Expose stats via STATUS command for debugging. Target: <3 commands in queue during normal typing.",2025-10-15,2025-10-15,Medium,
TASK-025,Implement partial region update optimization for display rendering,Pending,Display Engineer,Medium,TASK-015,"Enhance display refresh in rpi2/main.py display_worker_thread: (1) Calculate dirty region - compare previous frame buffer with new frame buffer to find minimal bounding box of changes, (2) Use EPD_4IN2_V2_PartialDisplay with region parameter to refresh only changed area (if display supports it), (3) If region <25% of screen, use partial refresh (1.5s), else use full refresh (4s) to prevent ghosting, (4) Track full refresh counter: force full refresh every 10 partial refreshes to clear accumulated ghosting. Store previous_framebuffer for comparison. Add region calculation function: find_dirty_region(old_fb, new_fb) -> (x, y, width, height). Measure refresh time reduction: target 50% faster for typical single-char insertion during typing.",2025-10-15,2025-10-15,Large,
TASK-026,Create comprehensive unit tests for Master Pico dual-core implementation,Pending,QA Engineer,High,"TASK-011,TASK-013","Create test suite in tests/test_master_dual_core.py: (1) test_file_io_queue_thread_safety - concurrent enqueue/dequeue from multiple threads, (2) test_lock_acquisition_order - verify no deadlock with text_buffer_lock + file_state_lock, (3) test_core1_crash_recovery - simulate Core 1 exception and verify restart, (4) test_typing_during_file_save - verify keyboard responsive during Core 1 file write, (5) test_queue_overflow_handling - fill queue beyond capacity and verify graceful degradation. Use micropython unittest framework. Mock hardware (TCA8418, UART) with test doubles. Run tests on actual Pico hardware for timing validation. Target: 100% code coverage of threading logic, all tests pass without race conditions.",2025-10-15,2025-10-15,Large,
TASK-027,Create comprehensive unit tests for Slave Pico dual-core implementation,Pending,QA Engineer,High,"TASK-014,TASK-016","Create test suite in tests/test_slave_dual_core.py: (1) test_display_queue_thread_safety - concurrent enqueue from UART receiver (Core 0) and dequeue from display worker (Core 1), (2) test_display_lock_contention - verify epd driver access serialization, (3) test_render_deduplication - enqueue 5 RENDER commands and verify only last one executes, (4) test_display_busy_timeout - simulate stuck display and verify worker recovery, (5) test_priority_command_preemption - verify POWER_OFF jumps queue ahead of pending RENDER. Mock display hardware with controllable busy signal. Measure queue latency under load. Target: sub-100ms average time from enqueue to render start.",2025-10-15,2025-10-15,Large,
TASK-028,Create integration tests for Master-Slave dual-core system,Pending,QA Engineer,Critical,"TASK-026,TASK-027","Create end-to-end test suite in tests/test_integration_dual_core.py: (1) test_typing_latency - measure keypress to display update latency (target <500ms), (2) test_sustained_typing - type 1000 chars rapidly and verify no dropped characters or crashes, (3) test_concurrent_save_and_typing - trigger file save while typing continues (verify no stutter), (4) test_power_management_flow - trigger screensaver then auto-off then wake sequence, (5) test_uart_command_loss - drop UART messages and verify Master retries, (6) test_memory_stability - run for 1hr typing session and monitor RAM usage (no leaks). Requires both Pico devices connected with UART. Automated test harness with keyboard input simulation. Log all timing metrics for performance regression detection.",2025-10-15,2025-10-15,XLarge,
TASK-029,Performance benchmarking - establish baseline metrics,Pending,Performance Engineer,High,TASK-028,"Measure current system performance before optimization: (1) Keypress to screen update latency - average, p95, p99 (test 1000 keypresses), (2) Characters per second throughput - sustained typing speed without lag, (3) File save operation time - for 1KB, 10KB, 100KB files, (4) Display refresh duration - partial vs full, with measurement via BUSY pin timing, (5) UART command round-trip time - send command to ACK response, (6) Memory usage - idle, during typing, during file operations, (7) Core 1 CPU utilization - percentage of time in worker vs idle. Create baseline_metrics.json with timestamp and hardware config. Use these metrics to validate optimization gains after dual-core implementation. Target improvements: 50% reduction in input latency, 2x increase in typing throughput.",2025-10-15,2025-10-15,Medium,
TASK-030,Performance benchmarking - measure post-optimization improvements,Pending,Performance Engineer,High,"TASK-029,TASK-028","Re-run all baseline benchmarks after dual-core and async implementation complete. Compare results against baseline_metrics.json: (1) Latency reduction - expect 40-60% improvement due to non-blocking architecture, (2) Throughput increase - expect 2-3x due to parallel processing, (3) Save operation - should not impact typing responsiveness (verify with concurrent test), (4) Display refresh - no change expected (hardware bound) but verify no degradation, (5) Memory overhead - document RAM increase from threading (expect <5KB), (6) Core utilization - verify both cores active and balanced. Generate optimization_metrics.json with delta analysis. Create visualizations: before/after latency histogram, throughput over time graph. Document findings in Performance_Report.md with recommendations for further optimization.",2025-10-15,2025-10-15,Medium,
TASK-031,Optimize memory usage for dual-core threading overhead,Pending,Performance Engineer,Medium,"TASK-011,TASK-014","Profile memory usage of dual-core implementation: (1) Measure baseline single-core RAM usage with gc.mem_free(), (2) Measure dual-core RAM usage after thread startup, (3) Identify memory overhead sources - queue buffers, lock objects, thread stacks, duplicate buffers. Optimizations: (1) Use fixed-size queues with pre-allocated slots (avoid dynamic allocation), (2) Reduce thread stack size if possible (default may be oversized), (3) Implement single frame buffer with lock instead of double-buffering if memory constrained, (4) Use memoryview for zero-copy buffer sharing between cores, (5) Aggressive gc.collect() before thread startup. Target: keep total RAM overhead <10KB. If memory pressure high, consider disabling Core 1 worker on low-memory condition with fallback to single-core mode.",2025-10-15,2025-10-15,Medium,
TASK-032,Implement error handling and recovery for dual-core edge cases,Pending,Reliability Engineer,High,"TASK-022,TASK-028","Add comprehensive error handling across dual-core system: (1) Core 1 exception handling - wrap worker thread in try/except, log exception to error.log, attempt restart, (2) Queue full conditions - implement backpressure or oldest-item-drop policy, notify user via status LED or display message, (3) Lock timeout scenarios - detect deadlock with timeout acquisition, force release and log error, (4) UART communication failures - implement retry with exponential backoff, fallback to safe state if sustained failures, (5) Display hardware errors - detect and recover from e-ink controller hung state. Create error code system: E001-E099 for Core 1 errors, E100-E199 for display errors, etc. Add error reporting UI: Fn+E shows last 10 errors on screen. Document all error codes in Error_Codes.md with recovery procedures.",2025-10-15,2025-10-15,Large,
TASK-033,Optimize TextLayout algorithm for performance,Pending,Algorithm Engineer,Medium,TASK-002,"Profile TextLayout class functions (get_word_boundaries, calculate_lines, get_screen_pages) to identify bottlenecks. Current implementation may recalculate full document layout on every character insertion. Optimizations: (1) Incremental layout - only recalculate changed paragraph, maintain layout cache for unchanged pages, (2) Lazy evaluation - defer get_screen_pages calculation until display refresh needed, (3) Line break caching - store word boundary results to avoid repeated string scans, (4) Use memoryview/bytearray instead of string manipulation where possible, (5) Move complex layout calculations to Core 1 if CPU-bound. Benchmark current vs optimized: measure time for calculate_lines on 10KB document (target <50ms). Ensure optimizations don't increase memory usage significantly. Update both Master and Slave TextLayout implementations if needed.",2025-10-15,2025-10-15,Large,
TASK-034,Implement smart backspace across page boundaries,Pending,Feature Developer,Medium,TASK-033,"Enhance delete_char() function in rpi1/main.py to handle backspace at page boundaries intelligently: (1) When cursor at start of subpage 1+ in explicit page, merge with previous subpage and adjust cursor, (2) When cursor at start of page 1+, offer to merge with previous page (show prompt 'Merge with previous page? Y/N'), (3) Maintain page break markers (---) integrity during deletion, (4) Update current_page_index and current_subpage_index correctly after merge, (5) Handle undo for accidental merges (store last deleted page in undo_buffer). Test edge cases: empty page deletion, very long page merging (overflow check), rapid backspace at boundary. This was noted as MVP feature in update_notes.json known issues. Improve user experience during document editing.",2025-10-15,2025-10-15,Medium,
TASK-035,Fix newline concatenation bug in page view navigation,Pending,Bug Fix,High,TASK-033,"Address known issue from update_notes.json: When using PgUp/PgDn to navigate pages, newlines are removed and lines concatenate. Root cause: TextLayout.extract_subpage_text() loses track of actual newlines vs wrapped lines. Solution approach: (1) Modify text storage to preserve newline metadata - use list of (char, is_newline) tuples or maintain separate newline position array, (2) Update extract_subpage_text() to reconstruct text with original newlines, not wrapped lines, (3) Add newline markers to line calculation in calculate_lines(), (4) Test with multi-page document containing explicit newlines vs natural wrapping. Alternative approach: Store pages with explicit newline characters (\n) and distinguish from soft wraps during rendering. Verify fix with: create page with 5 lines of text, navigate away, navigate back, confirm 5 lines still visible.",2025-10-15,2025-10-15,Medium,
TASK-036,Implement file menu deep sleep timeout,Pending,Feature Developer,Low,TASK-021,"Add power management to file_menu() function in rpi1/main.py: Currently file menu can stay open indefinitely. Enhancement: (1) Track menu_open_time when file_menu() called, (2) Check elapsed time during menu navigation loop, (3) After 2 minutes of no activity in menu (no PgUp/PgDn/Enter), show timeout warning on display 'Closing menu in 10 seconds...', (4) After 10s more, exit menu and return to last edited file or home screen, (5) After 5 minutes total idle, trigger same auto-off sequence as main editor. Reset activity timer on any key press in menu. Maintain consistency with main editor idle timeouts (2min screensaver, 5min off). Noted as MVP feature in update_notes.json next tasks.",2025-10-15,2025-10-15,Small,
TASK-037,Code documentation and inline comments for dual-core implementation,Pending,Documentation Engineer,Medium,"TASK-011,TASK-014","Add comprehensive inline documentation to all dual-core code: (1) Function docstrings explaining purpose, parameters, return values, side effects, (2) Comments explaining thread safety approach - which locks protect which data, (3) Diagram in ASCII art showing Core 0 and Core 1 responsibilities and communication paths, (4) Lock acquisition order documentation to prevent deadlocks, (5) Queue message format documentation with examples. Update existing functions with threading implications explained. Create Threading_Architecture.md with visual diagrams of: Master Core 0 ↔ Master Core 1 communication, Slave Core 0 ↔ Slave Core 1 communication, Master ↔ Slave UART protocol. Follow project guidelines: explain code with comments when updating. Make code maintainable for future developers unfamiliar with threading.",2025-10-15,2025-10-15,Medium,
TASK-038,Create architectural documentation with ASCII diagrams,Completed,Documentation Engineer,High,TASK-008,"Create comprehensive system architecture documentation: (1) Physical hardware layout - both Picos, connections, pin assignments, (2) Software architecture - Core 0 vs Core 1 responsibilities on each Pico, (3) Data flow diagrams - keypress to display update path, file save path, power management flow, (4) Threading model - locks, queues, message passing, (5) UART protocol - command structure, ack/nak, error handling. Use ASCII art for diagrams per user instructions. Document in Architecture.md file. Include code file map: which files run on which device/core, what functions are in each file, complexity annotations for complex functions. This satisfies user requirement to 'keep architectural map of code files functions used within them and for complex functions draw out logical diagram using ascii art'.",2025-10-15,2025-10-15,Large,1.5hr
TASK-039,Update update_notes.json with dual-core optimization changes,Pending,Documentation Engineer,High,"TASK-030,TASK-037","Create update_number 3 entry in update_notes.json documenting dual-core optimization implementation: List all files modified (rpi1/main.py, rpi2/main.py, new queue files, test files), detail changes made (dual-core threading, async tasks, lock protection, queue systems, performance optimizations), note any architectural changes from previous Master-Slave design, document performance improvements with metrics from benchmarking, list any new dependencies or MicroPython modules required (_thread, uasyncio, etc.), record any issues encountered and solutions, set next_task to remaining features or future enhancements. Maintain consistency with previous update entries format. Ensure comprehensive record for project history and future reference. Follow project guideline: Ensure all code updates made are noted in update_notes.json.",2025-10-15,2025-10-15,Small,
TASK-040,Hardware validation - wire and test Master Pico Core 1 background tasks,Pending,Hardware QA,Critical,"TASK-011,TASK-012,TASK-013","Physical hardware testing of Master Pico dual-core implementation: (1) Flash rpi1/main.py to Master Pico 2W hardware, (2) Connect TCA8418 keyboard on I2C1 (verify GP2/GP3/GP20/GP21 wiring), (3) Connect UART to Slave Pico (verify GP8 TX / GP9 RX), (4) Add debug print statements to Core 0 and Core 1 to verify both running, (5) Test typing while Core 1 performs file save - verify no keyboard lag, (6) Monitor serial console for threading errors or lock contention messages, (7) Test sustained typing session (10 minutes) for stability, (8) Use oscilloscope on UART lines to verify command transmission during Core 1 file operations. Document any hardware-specific issues (timing, lock duration, memory pressure). Iterate on implementation if hardware behavior differs from simulation.",2025-10-15,2025-10-15,Large,
TASK-041,Hardware validation - wire and test Slave Pico Core 1 display rendering,Pending,Hardware QA,Critical,"TASK-014,TASK-015,TASK-016","Physical hardware testing of Slave Pico dual-core implementation: (1) Flash rpi2/main.py to Slave Pico 2W hardware, (2) Connect Waveshare 4.2 inch e-ink display on SPI1 (verify GP10/GP11/GP13/GP14/GP15/GP16 wiring), (3) Connect UART from Master Pico (verify GP8 RX / GP9 TX), (4) Add debug LED toggle in display_worker_thread to visually confirm Core 1 activity, (5) Send test UART commands from Master and verify display updates, (6) Measure display refresh timing with timer - confirm 1.5s partial refresh not delayed by Core 0 UART processing, (7) Test rapid UART command stream (simulate fast typing) and verify queue deduplication works, (8) Monitor display quality - check for ghosting, partial refresh artifacts. Use logic analyzer on SPI bus to verify clean display communication. Document actual vs expected performance.",2025-10-15,2025-10-15,Large,
TASK-042,Hardware validation - end-to-end typing latency measurement,Pending,Hardware QA,Critical,"TASK-040,TASK-041","Integrated system testing with both Picos and full hardware: (1) Connect Master to Slave via UART, connect keyboard to Master, connect display to Slave, (2) Set up latency measurement rig: oscilloscope probes on keyboard INT line (GP20) and display BUSY line (GP16), (3) Type single character and measure time from INT falling edge to BUSY rising edge (this is end-to-end latency), (4) Repeat for 100 keypresses and calculate average, p95, p99 latency, (5) Compare against pre-optimization baseline (if available) or theoretical minimum (TCA8418 scan time + Master processing + UART transfer + Slave processing + display setup time), (6) Test typing burst (rapid 10 chars) and measure total time vs 10x single char time (should be less due to batching), (7) Verify latency consistent during concurrent file save operation. Target: <500ms average latency. Document in Performance_Report.md.",2025-10-15,2025-10-15,Medium,
TASK-043,Hardware validation - power management testing,Pending,Hardware QA,High,"TASK-040,TASK-041","Test power management features on physical hardware: (1) Boot system and remain idle (no typing), (2) Verify screensaver activates after exactly 2 minutes (120s ± 5s tolerance), (3) Verify system powers off (lightsleep) after 5 minutes total (300s ± 10s), (4) Press any key to wake system from sleep, verify wake-up time <2s, (5) Verify text buffer preserved after wake (type before sleep, wake, verify text still on display), (6) Test Fn+Q hold for 2s to trigger manual power-off, (7) Measure power consumption: active typing, idle, screensaver, lightsleep (use multimeter on Pico 2W power pins), (8) Verify both Picos power down in coordinated manner. Document power consumption values in Power_Management.md. Validate against RP2350 datasheet typical values.",2025-10-15,2025-10-15,Medium,
TASK-044,Hardware validation - stress testing and reliability,Pending,Hardware QA,High,"TASK-040,TASK-041,TASK-042","Long-duration stress testing on physical hardware: (1) Extended typing session - 2 hours continuous typing with periodic file saves, monitor for crashes/hangs/memory leaks, (2) Power cycling - 50 cycles of wake/sleep/wake, verify no corruption or failures, (3) Rapid command stress - send 1000 UART commands in rapid succession, verify no lost commands or queue overflows, (4) Memory exhaustion test - create very large document (100KB+) and verify graceful handling or clear limit, (5) Environmental test - operate in temperature range 15-30C and verify stable, (6) Vibration test - simulate portable use with movement while typing, verify no loose connections. Log all failures to test_failures.log with timestamp, conditions, and symptoms. Fix any identified issues and re-test until 2hr clean run achieved. This validates production readiness.",2025-10-15,2025-10-15,XLarge,
TASK-045,Code cleanup - remove obsolete main.py variants,Pending,Code Maintainer,Low,"TASK-030,TASK-040","Clean up obsolete code files after dual-core optimization complete: (1) Identify which version is production - likely new dual-core optimized version, (2) Remove or archive old files: main_improved.py (duplicate), main_optimized.py (superseded by new dual-core implementation), original main.py (ESP32 version), (3) Rename final production version to canonical main.py name, (4) Update boot.py to import correct main.py, (5) Remove unused imports and commented-out code, (6) Remove debug print statements added during development (or make conditional on DEBUG flag), (7) Archive old versions to archive/ directory for reference rather than deleting. Document in update_notes.json which files were removed/archived and why. Keep codebase clean and maintainable. This was noted in update 1 next_task: 'identify optimal version and remove redundant files'.",2025-10-15,2025-10-15,Small,
TASK-046,Implement WiFi transfer optimization with Core 1 offload,Pending,Network Engineer,Medium,TASK-012,"Enhance WiFi file transfer functionality to leverage Master Core 1: (1) Move WiFi connection and upload operations to Core 1 file_io_worker, (2) Implement non-blocking WiFi connect with timeout, (3) Use streaming upload instead of loading full file to RAM (especially for large files), (4) Add progress indication - Core 1 updates shared progress variable (0-100%), Core 0 displays progress on screen via UART command to Slave, (5) Implement retry logic for failed uploads (max 3 attempts with exponential backoff), (6) Add upload queue - user can trigger multiple uploads and they process sequentially in Core 1 background, (7) Show status LED or display indicator when upload in progress. Verify keyboard remains responsive during WiFi operations (this is key benefit of dual-core). Test with poor WiFi conditions (weak signal, intermittent connectivity). Measure throughput improvement.",2025-10-15,2025-10-15,Large,
TASK-047,Implement Todoist upload optimization with Core 1 offload,Pending,Network Engineer,Medium,TASK-012,"Enhance Todoist integration to leverage Master Core 1: (1) Move Todoist API calls to Core 1 file_io_worker, (2) Implement chunked upload for large documents (Todoist task size limits), (3) Add metadata to Todoist tasks - file name, word count, timestamp, (4) Implement upload queue separate from WiFi transfer queue (different priorities), (5) Add user feedback - show 'Uploading to Todoist...' message on display via Slave, (6) Cache Todoist auth token validation to avoid repeated auth overhead, (7) Handle API errors gracefully - rate limiting, network errors, invalid token. Verify typing continues uninterrupted during Todoist upload. Test with various file sizes: small (1KB), medium (10KB), large (100KB). Document Todoist API usage patterns in integration notes.",2025-10-15,2025-10-15,Large,
TASK-048,Implement graceful degradation for single-core fallback mode,Pending,Reliability Engineer,Medium,TASK-032,"Add fallback mechanism if dual-core fails: (1) Detect Core 1 startup failure (thread exception on start_new_thread), (2) Set global SINGLE_CORE_MODE flag, (3) Implement fallback functions: blocking_file_save(), blocking_display_render() that execute on Core 0, (4) Disable background operations: no auto-save during typing, manual save only, no concurrent uploads, (5) Show warning on display 'Running in safe mode - save frequently', (6) Log fallback event with reason, (7) Provide recovery option: Fn+R attempts to restart Core 1 worker. Test fallback: artificially fail Core 1 startup and verify system remains usable. Ensures device usable even if optimization fails, maintains reliability over performance. Document fallback limitations in user guide.",2025-10-15,2025-10-15,Medium,
TASK-049,Security review - UART protocol validation and error handling,Pending,Security Engineer,Medium,TASK-023,"Review UART communication for security and robustness: (1) Validate JSON command structure - check for required fields, reject malformed commands, (2) Implement command size limits - prevent buffer overflow from excessively long commands (max 4KB), (3) Add command authentication - simple shared secret or sequence number validation to detect command injection if UART exposed, (4) Sanitize text content - handle special characters, null bytes, escape sequences safely, (5) Implement timeout on UART read - prevent infinite wait on incomplete command, (6) Add checksum or CRC for command integrity detection (detect corruption on noisy UART line), (7) Rate limiting - reject >100 commands/sec to prevent DoS. Test with malicious inputs: overly long commands, malformed JSON, rapid command spam, null bytes. Document protocol security in UART_Protocol.md.",2025-10-15,2025-10-15,Medium,
TASK-050,User acceptance testing - real-world writing scenarios,Pending,Product Manager,High,"TASK-044,TASK-045","Conduct user acceptance testing with target use cases: (1) Short note - write 1 paragraph note (100 words), save, verify retrieval, (2) Long document - write 5 page article (1000+ words), navigate between pages, edit earlier pages, verify consistency, (3) Multiple files - create 10 different documents, switch between them with file menu, verify no cross-contamination, (4) Cloud backup - write document and upload to Todoist, verify content accuracy on Todoist web/app, (5) Power management - write document, walk away, return after screensaver/auto-off, resume writing, verify no data loss, (6) Typo correction - extensive backspace/edit operations across pages, verify word wrap recalculates correctly. Recruit 3 beta users for feedback. Document usability issues in UAT_Feedback.md. Iterate on UX pain points. Success criteria: users can complete all tasks without crashes or data loss.",2025-10-15,2025-10-15,XLarge,
